---
import type { CollectionEntry } from 'astro:content'
import type { MarkdownHeading } from 'astro'
import SimpleProgressRing from './SimpleProgressRing.astro'
import { cn } from '~/lib/utils'

interface Props {
  post: CollectionEntry<'posts'>
  posts: CollectionEntry<'posts'>[]
  headings: MarkdownHeading[]
}

const { headings } = Astro.props
const hasHeadings = headings.length > 0

// 过滤并处理标题
const filteredHeadings = headings
  .filter((h) => h.depth <= 4 && h.text.trim())
  .map((h, index) => ({
    ...h,
    text: h.text.replace(/\s*[Hh][1-6]$/g, ''),
    order: index + 1,
  }))

// 计算相对缩进 - 基于实际存在的最小层级
const minDepth = filteredHeadings.length > 0 ? Math.min(...filteredHeadings.map((h) => h.depth)) : 2
const getRelativeIndentClass = (depth: number) => {
  const relativeDepth = depth - minDepth
  const indentMap = ['ml-0', 'ml-4', 'ml-8', 'ml-12'] // 最多支持4级相对缩进
  return indentMap[relativeDepth] || 'ml-12'
}
---

{
  hasHeadings && (
    <div id="mobile-toc-container" class="xl:hidden sticky top-0 z-30">
      <div class="relative">
        <button
          class="flex w-full cursor-pointer items-center justify-between relative md:bg-transparent bg-background/95 backdrop-blur-sm border-b border-border/60 px-6 sm:px-8 py-3 select-none"
          data-toc-toggle
        >
          <div class="flex gap-4 items-center min-w-0 flex-1">
            <SimpleProgressRing size={16} strokeWidth={2} class="flex-shrink-0" />
            <span id="mobile-toc-current-section" class="text-sm font-medium text-foreground/80 truncate">
              Overview
            </span>
          </div>
          <div class="flex items-center gap-2 pl-2">
            <span class="icon-[ph--caret-down] w-4 h-4 text-primary/70 transition-transform duration-200" data-toc-arrow />
          </div>
        </button>

        <div
          class="md:bg-transparent bg-background/98 backdrop-blur-sm border-b border-border/30 overflow-hidden max-h-0 transition-[max-height] duration-300 ease-in-out"
          data-toc-content
        >
          <div class="relative">
            <div
              class="absolute top-0 left-0 right-0 h-8 bg-gradient-to-b from-background/98 to-transparent pointer-events-none z-10 opacity-0 transition-opacity duration-200"
              data-fade-top
            />
            <div
              class="absolute bottom-0 left-0 right-0 h-8 bg-gradient-to-t from-background/98 to-transparent pointer-events-none z-10 opacity-0 transition-opacity duration-200"
              data-fade-bottom
            />

            <div class="max-h-[30vh] overflow-y-auto no-scrollbar" data-toc-scroll-area>
              <ul class="px-6 sm:px-8 py-2 space-y-2" id="mobile-table-of-contents">
                {filteredHeadings.map((heading) => {
                  const depthClass = heading.depth === 1 ? 'font-medium text-foreground' : 'text-foreground/60 hover:text-foreground/90'
                  return (
                    <li class={cn('flex items-start gap-2 min-w-0', depthClass, getRelativeIndentClass(heading.depth) || '')}>
                      <span
                        class="text-primary/40 font-mono text-xs mt-1 min-w-[1.5rem] transition-colors duration-200 flex-shrink-0 mobile-toc-number"
                        data-order={heading.order}
                      >
                        {heading.order.toString().padStart(2, '0')}
                      </span>
                      <a
                        href={`#${heading.slug}`}
                        class="text-sm text-foreground/70 hover:text-primary hover:underline transition-colors duration-200 leading-relaxed truncate mobile-toc-item"
                        data-heading-id={heading.slug}
                        data-heading-text={heading.text}
                      >
                        {heading.text}
                      </a>
                    </li>
                  )
                })}
              </ul>
            </div>
          </div>
        </div>
      </div>
    </div>
  )
}

<script>
  const INITIAL_OVERVIEW_TEXT = 'Overview'
  const TOC_OFFSET = 80

  class MobileTOCState {
    currentSectionText: HTMLElement | null = null
    detailsElement: HTMLDetailsElement | null = null
    listElement: HTMLElement | null = null
    scrollArea: HTMLElement | null = null
    fadeTop: HTMLElement | null = null
    fadeBottom: HTMLElement | null = null
    headings: HTMLElement[] = []
    regions: { id: string; start: number; end: number }[] = []
    activeIds: string[] = []

    reset(): void {
      this.currentSectionText = document.getElementById('mobile-toc-current-section')
      this.detailsElement = document.querySelector('#mobile-toc-container details')
      this.listElement = document.getElementById('mobile-table-of-contents')
      this.scrollArea = document.querySelector('[data-toc-scroll-area]')
      this.fadeTop = document.querySelector('[data-fade-top]')
      this.fadeBottom = document.querySelector('[data-fade-bottom]')
      this.headings = []
      this.regions = []
      this.activeIds = []
    }
  }

  const state = new MobileTOCState()

  class MobileHeadingObserver {
    private static observer: IntersectionObserver | null = null
    private static currentActiveHeading: string | null = null

    static init(): void {
      // 获取所有标题，排除脚注
      state.headings = Array.from(document.querySelectorAll<HTMLElement>('h1[id], h2[id], h3[id], h4[id]')).filter(
        (heading) => heading.id !== 'footnote-label'
      )

      if (state.headings.length === 0) return

      const headingLinks = document.querySelectorAll('.mobile-toc-item')

      if (!headingLinks.length) return

      // 创建与桌面端相同的 IntersectionObserver
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.intersectionRatio > 0) {
              const id = entry.target.id
              if (this.currentActiveHeading === id) return

              this.currentActiveHeading = id
              state.activeIds = [id]
              MobileTOCLinks.updateActiveHeading(id)
            }
          })
        },
        {
          // 使用与桌面端相同的检测参数
          rootMargin: '-80px 0px -85% 0px',
          threshold: [0, 1],
        }
      )

      // 观察所有标题
      state.headings.forEach((heading) => this.observer?.observe(heading))

      // 页面加载时检查当前可见的标题
      setTimeout(() => {
        const visibleHeading = state.headings.find((heading) => {
          const rect = heading.getBoundingClientRect()
          return rect.top > 10 && rect.top < window.innerHeight * 0.33
        })

        if (visibleHeading) {
          state.activeIds = [visibleHeading.id]
        } else if (state.headings.length > 0) {
          // 如果没有可见标题，显示Overview
          state.activeIds = []
        }

        MobileTOCLinks.updateActiveHeading(state.activeIds[0] || '')
      }, 100)
    }

    static cleanup(): void {
      if (this.observer) {
        this.observer.disconnect()
        this.observer = null
      }
      this.currentActiveHeading = null
    }
  }

  class TOCScrollMask {
    static update(): void {
      if (!state.scrollArea || !state.fadeTop || !state.fadeBottom) return

      const { scrollTop, scrollHeight, clientHeight } = state.scrollArea
      const threshold = 10

      const showTopFade = scrollTop > threshold
      const showBottomFade = scrollTop < scrollHeight - clientHeight - threshold

      state.fadeTop.style.opacity = showTopFade ? '1' : '0'
      state.fadeBottom.style.opacity = showBottomFade ? '1' : '0'
    }
  }

  class MobileTOCLinks {
    static updateActiveHeading(activeId: string): void {
      if (!state.listElement || !state.currentSectionText) return

      const headingLinks = state.listElement.querySelectorAll('.mobile-toc-item')
      const headingNumbers = state.listElement.querySelectorAll('.mobile-toc-number')

      // 重置所有项目状态
      headingLinks.forEach((link) => {
        const tocItem = link as HTMLElement
        tocItem.classList.remove('text-primary', 'font-semibold')
        tocItem.classList.add('text-foreground/70')
      })

      headingNumbers.forEach((number) => {
        const tocNumber = number as HTMLElement
        tocNumber.classList.remove('text-primary', 'font-semibold')
        tocNumber.classList.add('text-primary/40')
      })

      // 更新当前章节文本
      let textToShow = INITIAL_OVERVIEW_TEXT

      // 高亮当前活跃项
      if (activeId) {
        const activeItem = state.listElement.querySelector(`[data-heading-id="${activeId}"]`) as HTMLElement
        const activeNumber = state.listElement.querySelector(`[data-order="${this.getOrderByHeadingId(activeId)}"]`) as HTMLElement

        if (activeItem) {
          activeItem.classList.remove('text-foreground/70')
          activeItem.classList.add('text-primary', 'font-semibold')

          // 获取标题文本
          const cleanText = activeItem.dataset.headingText
          if (cleanText) {
            textToShow = cleanText
          }
        }

        if (activeNumber) {
          activeNumber.classList.remove('text-primary/40')
          activeNumber.classList.add('text-primary', 'font-semibold')
        }

        this.scrollToActive(activeId)
      }

      state.currentSectionText.textContent = textToShow
    }

    static getOrderByHeadingId(headingId: string): string {
      const item = state.listElement?.querySelector(`[data-heading-id="${headingId}"]`)
      return item?.getAttribute('data-heading-text') || ''
    }

    static scrollToActive(activeHeadingId: string): void {
      if (!state.listElement || !state.scrollArea) return

      const activeItem = state.listElement.querySelector(`[data-heading-id="${activeHeadingId}"]`)
      if (!activeItem) return

      const containerRect = state.scrollArea.getBoundingClientRect()
      const itemRect = activeItem.getBoundingClientRect()

      const relativeTop = itemRect.top - containerRect.top + state.scrollArea.scrollTop
      const targetScrollTop = relativeTop - containerRect.height / 2 + itemRect.height / 2

      const targetScroll = Math.max(0, Math.min(targetScrollTop, state.scrollArea.scrollHeight - state.scrollArea.clientHeight))

      if (Math.abs(targetScroll - state.scrollArea.scrollTop) > 5) {
        state.scrollArea.scrollTo({
          top: targetScroll,
          behavior: 'smooth',
        })
      }
    }

    static setupInteraction(): void {
      const toggleButton = document.querySelector('[data-toc-toggle]') as HTMLElement | null
      const tocContent = document.querySelector('[data-toc-content]') as HTMLElement | null
      const tocArrow = document.querySelector('[data-toc-arrow]') as HTMLElement | null

      let isOpen = false

      // 获取目录当前状态
      const isTocOpen = () => {
        if (!tocContent) return false
        return tocContent.style.maxHeight !== '0px' && tocContent.style.maxHeight !== '' && tocContent.style.maxHeight !== '0'
      }

      if (toggleButton && tocContent && tocArrow) {
        toggleButton.addEventListener('click', () => {
          isOpen = !isOpen

          if (isOpen) {
            // 设置免疫期，防止刚打开就被滚动监听器关闭
            MobileTOCController.setRecentlyOpened(true)
            setTimeout(() => MobileTOCController.setRecentlyOpened(false), 800)

            // 使用一个足够大的 max-height 值来容纳内容
            tocContent.style.maxHeight = '31vh'
            tocArrow.style.transform = 'rotate(180deg)'
            setTimeout(() => TOCScrollMask.update(), 100)
          } else {
            tocContent.style.maxHeight = '0'
            tocArrow.style.transform = 'rotate(0deg)'
          }
        })
      }

      if (!state.listElement) return

      // 目录链接点击处理
      state.listElement.querySelectorAll('.mobile-toc-item').forEach((item) => {
        item.addEventListener('click', (e) => {
          // 如果目录是收缩状态，只打开目录，不跳转
          if (!isTocOpen()) {
            e.preventDefault()

            // 打开目录
            if (tocContent && tocArrow) {
              isOpen = true
              MobileTOCController.setRecentlyOpened(true)
              setTimeout(() => MobileTOCController.setRecentlyOpened(false), 800)

              tocContent.style.maxHeight = '31vh'
              tocArrow.style.transform = 'rotate(180deg)'
              setTimeout(() => TOCScrollMask.update(), 100)
            }
            return
          }

          // 如果目录是展开状态，先关闭目录，然后手动跳转
          if (tocContent && tocArrow) {
            e.preventDefault() // 阻止原生跳转

            // 先关闭目录
            isOpen = false
            tocContent.style.maxHeight = '0'
            tocArrow.style.transform = 'rotate(0deg)'

            // 等待目录关闭动画完成后再跳转
            setTimeout(() => {
              const href = (item as HTMLElement).getAttribute('href')
              if (href) {
                const target = document.querySelector(href)
                if (target) {
                  const rect = target.getBoundingClientRect()
                  const documentTop = rect.top + window.scrollY
                  const scrollPosition = documentTop - 80 // 距离顶部80px

                  window.scrollTo({
                    top: Math.max(0, scrollPosition),
                    behavior: 'smooth',
                  })
                }
              }
            }, 300) // 等待目录关闭动画完成
          }
        })
      })

      // 设置滚动区域遮罩
      if (state.scrollArea) {
        state.scrollArea.addEventListener('scroll', TOCScrollMask.update, { passive: true })
      }
    }
  }

  class MobileTOCController {
    private static scrollRAF: number | null = null
    private static resizeRAF: number | null = null
    private static observer: IntersectionObserver | null = null
    private static isStuck = false
    private static lastScrollY = 0
    private static boundHandleScroll: (() => void) | null = null
    private static boundHandleResize: (() => void) | null = null
    private static recentlyOpened = false // 防止刚打开就被关闭

    static handleScroll(): void {
      if (this.scrollRAF) return

      this.scrollRAF = requestAnimationFrame(() => {
        const currentScrollY = window.scrollY
        const isScrollingDown = currentScrollY > this.lastScrollY

        // 如果 sticky 未激活且向下滚动，则关闭Overview（但不在刚打开时关闭）
        if (!this.isStuck && isScrollingDown && !this.recentlyOpened) {
          const tocContent = document.querySelector('[data-toc-content]') as HTMLElement | null
          const tocArrow = document.querySelector('[data-toc-arrow]') as HTMLElement | null

          if (tocContent && tocArrow) {
            const isOpen = tocContent.style.maxHeight !== '0px' && tocContent.style.maxHeight !== '' && tocContent.style.maxHeight !== '0'
            if (isOpen) {
              tocContent.style.maxHeight = '0'
              tocArrow.style.transform = 'rotate(0deg)'
            }
          }
        }

        this.lastScrollY = currentScrollY
        this.scrollRAF = null
      })
    }

    static handleResize(): void {
      if (this.resizeRAF) return

      this.resizeRAF = requestAnimationFrame(() => {
        // 重新初始化观察器
        MobileHeadingObserver.cleanup()
        MobileHeadingObserver.init()
        this.resizeRAF = null
      })
    }

    static init(): void {
      state.reset()

      // 初始化滚动位置
      this.lastScrollY = window.scrollY

      if (!state.currentSectionText) return

      // 添加 sticky 状态检测
      const tocContainer = document.getElementById('mobile-toc-container')
      const tocContent = document.querySelector('[data-toc-content]') as HTMLElement

      if (tocContainer && tocContent) {
        // 创建检测元素
        const sentinel = document.createElement('div')
        sentinel.style.position = 'absolute'
        sentinel.style.height = '1px'
        sentinel.style.top = `${tocContainer.offsetTop - 1}px`
        tocContainer.parentElement?.insertBefore(sentinel, tocContainer)

        // 观察器
        this.observer = new IntersectionObserver(
          ([entry]) => {
            this.isStuck = !entry.isIntersecting

            // 动态切换定位模式
            if (this.isStuck) {
              // sticky 激活：变为浮层
              tocContent.style.position = 'absolute'
              tocContent.style.top = '100%'
              tocContent.style.left = '0'
              tocContent.style.right = '0'
              tocContent.style.zIndex = '10'
            } else {
              // sticky 未激活：占据文档流
              tocContent.style.position = 'static'
              tocContent.style.top = 'auto'
              tocContent.style.left = 'auto'
              tocContent.style.right = 'auto'
              tocContent.style.zIndex = 'auto'
            }
          },
          { threshold: [0] }
        )

        this.observer.observe(sentinel)
      }

      // 初始化标题观察器和交互
      MobileHeadingObserver.init()
      MobileTOCLinks.setupInteraction()

      // 使用 passive 监听器优化性能
      this.boundHandleScroll = () => this.handleScroll()
      this.boundHandleResize = () => this.handleResize()

      window.addEventListener('scroll', this.boundHandleScroll, { passive: true })
      window.addEventListener('resize', this.boundHandleResize, { passive: true })
    }

    static setRecentlyOpened(value: boolean): void {
      this.recentlyOpened = value
    }

    static cleanup(): void {
      if (this.scrollRAF) {
        cancelAnimationFrame(this.scrollRAF)
        this.scrollRAF = null
      }
      if (this.resizeRAF) {
        cancelAnimationFrame(this.resizeRAF)
        this.resizeRAF = null
      }
      if (this.observer) {
        this.observer.disconnect()
        this.observer = null
      }

      this.lastScrollY = 0
      this.recentlyOpened = false

      if (this.boundHandleScroll) {
        window.removeEventListener('scroll', this.boundHandleScroll)
        this.boundHandleScroll = null
      }

      if (this.boundHandleResize) {
        window.removeEventListener('resize', this.boundHandleResize)
        this.boundHandleResize = null
      }

      // 清理标题观察器
      MobileHeadingObserver.cleanup()

      state.activeIds = []
      state.headings = []
      state.regions = []
    }
  }

  // 生命周期管理
  document.addEventListener('astro:page-load', () => MobileTOCController.init())
  document.addEventListener('astro:after-swap', () => {
    MobileTOCController.cleanup()
    MobileTOCController.init()
  })
  document.addEventListener('astro:before-swap', () => MobileTOCController.cleanup())
</script>
